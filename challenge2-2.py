# -*- coding: utf-8 -*-
"""Challenge2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U9eDLTad6oGLEUNuzVmAEuWiTatfc7FN
"""

# -- Uncomment following line if running in Google Colab
! pip install -q 'gwosc==0.5.4'
! pip install pycbc
! pip install -q 'gwpy==3.0.8'

# Commented out IPython magic to ensure Python compatibility.

# %matplotlib inline
from pycbc.catalog import Merger
from pycbc.waveform import get_td_waveform
import pylab
from pycbc.psd import interpolate, inverse_spectrum_truncation
from gwosc.datasets import find_datasets
from gwosc import datasets
from gwosc.datasets import event_gps
from gwpy.timeseries import TimeSeries
from pycbc import frame
from pycbc.waveform import get_fd_waveform, get_td_waveform
from pycbc.filter import matched_filter
from pycbc.conversions import mass1_from_mchirp_q
from pycbc.filter import resample_to_delta_t, highpass
import numpy
import os

from google.colab import drive
drive.mount('/content/drive')

T = TimeSeries.read('/content/drive/MyDrive/challenge2.gwf', 'H1:CHALLENGE2')
hq = T.q_transform(frange=(30, 300), qrange=(30, 50), outseg=(-19,-10))
plot = hq.plot()
plot.colorbar(label="Normalised energy")
ax = plot.gca()
ax.set_yscale("log")
plot.show
print(T.sample_rate)

print(T.duration)
print(T.sample_rate)

apx = 'SEOBNRv4_opt'
sample_rate = 4096 # samples per second
data_length = 128 # seconds

# Generate a long stretch of white noise: the data series and the time series.
data = numpy.random.normal(size=[sample_rate * data_length])
times = numpy.arange(len(data)) / float(sample_rate)
hp, hc = get_td_waveform(approximant=apx,
                         mass1=30,
                         mass2=30,
                         spin1z=0,
                         delta_t=1.0/sample_rate,
                         f_lower=25)
#hp1 = hp1 / max(numpy.correlate(hp1, hp1, mode='full'))**0.5

pylab.figure(figsize=pylab.figaspect(0.4))
pylab.plot(hp.sample_times, hp, label='Plus Polarization')
pylab.plot(hp.sample_times, hc, label='Cross Polarization')
pylab.xlabel('Time (s)')
pylab.ylabel('Strain')
pylab.legend()
pylab.grid()
pylab.show()

# Zoom in near the merger time
pylab.figure(figsize=pylab.figaspect(0.4))
pylab.plot(hp.sample_times, hp, label='Plus Polarization')
pylab.plot(hp.sample_times, hc, label='Cross Polarization')
pylab.xlabel('Time (s)')
pylab.ylabel('Strain')
pylab.xlim(-.01, .01)
pylab.legend()
pylab.grid()
pylab.show()

#Converting the data into time series data
T = frame.read_frame('challenge2.gwf', 'H1:CHALLENGE2')
strain = highpass(T, 15)
strain = resample_to_delta_t(strain, 1.0/2048)

pylab.plot(strain.sample_times, strain)
pylab.xlabel('Time (s)')
pylab.title("Before cut")
pylab.show()

# Remove 2 seconds of data from the beginning
conditioned = strain.crop(2, 2)

pylab.plot(conditioned.sample_times, conditioned)
pylab.xlabel('Time (s)')
pylab.show()

#Computing the PSD
psd = conditioned.psd(4)
psd = interpolate(psd, conditioned.delta_f)
psd = inverse_spectrum_truncation(psd, int(4 * conditioned.sample_rate),
                                  low_frequency_cutoff=20)
pylab.loglog(psd.sample_frequencies,psd)
pylab.xlim(xmin=20, xmax=1024)
pylab.ylim(1e-48, 1e-45)

from pycbc.waveform import get_td_waveform

m = 30 # Solar masses
hp, hc = get_td_waveform(approximant="SEOBNRv4_opt",
                     mass1=m,
                     mass2=m,
                     delta_t=conditioned.delta_t,
                     f_lower=20)

# Resize the vector to match our data
hp.resize(len(conditioned))

pylab.figure()
pylab.title('Before shifting')
pylab.plot(hp.sample_times, hp)
pylab.xlabel('Time (s)')
pylab.ylabel('Strain')
  #template
template = hp.cyclic_time_shift(hp.start_time)

pylab.figure()
pylab.title('After shifting')
pylab.plot(template.sample_times, template)
pylab.xlabel('Time (s)')
pylab.ylabel('Strain')

from pycbc.filter import matched_filter
import numpy
#Filtering the template
snr = matched_filter(template, conditioned,
                     psd=psd, low_frequency_cutoff=20)

snr = snr.crop(4 + 4, 4)


pylab.figure(figsize=[10, 4])
pylab.plot(snr.sample_times, abs(snr))
pylab.ylabel('Signal-to-noise')
pylab.xlabel('Time (s)')
pylab.show()

peak = abs(snr).numpy().argmax()
snrp = snr[peak]
time = snr.sample_times[peak]

print("We found a signal at {}s with SNR {}".format(time,
                                                    abs(snrp)))