# -*- coding: utf-8 -*-
"""Assignement3Week3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Cmaq-303cWzjVE5poUeU0VqYs-mwZarH
"""

import sys
!{sys.executable} -m pip install pycbc ligo-common --no-cache-dir

! pip install -q 'gwosc==0.5.4'
! pip install pycbc
! pip install -q 'gwpy==3.0.8'

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
from pycbc.waveform import get_td_waveform
from pycbc.psd import interpolate, inverse_spectrum_truncation
from gwosc.datasets import find_datasets
from gwosc import datasets
from gwosc.datasets import event_gps
from gwpy.timeseries import TimeSeries
from pycbc import frame
from pycbc.waveform import get_fd_waveform, get_td_waveform
from pycbc.filter import matched_filter
from pycbc.conversions import mass1_from_mchirp_q
from pycbc.filter import resample_to_delta_t, highpass
import pylab
from pycbc.catalog import Merger
from pycbc.frame import read_frame
from pycbc.waveform import td_approximants, fd_approximants
import numpy as np
import os
from google.colab import drive
drive.mount('/content/drive')

#Reading the second dataset from LIGO Hanford
data2 = np.load('/content/drive/MyDrive/noise_ts_4096Hz.npy')

#Retrieving the Time and Strain data from the file
Time = data2[:, 0]
Strain = data2[:,1]

#Converting the data into time series data
import pycbc.types
DT = Time[1]-Time[0]
Data = pycbc.types.TimeSeries(data2[:,1], delta_t=DT)

strain = highpass(Data, 20.0)
strain = resample_to_delta_t(strain, 1.0/2048)
pylab.plot(strain.sample_times, strain)

conditioned = strain.crop(2, 2)

mass1 = np.arange(5, 10,0.2 )
mass2 = mass1
Snr_list = []
#Generating a waveform in a loop to get all the masses
for i in range(len(mass1)):

    m = mass1[i] # Solar masses
    hp, hc = get_td_waveform(approximant="TaylorT2",
                     mass1=m,
                     mass2=m,
                     delta_t=strain.delta_t,
                     f_lower=15)

    # Resizing to match the data
    hp.resize(len(conditioned))

    #template
    template = hp.cyclic_time_shift(hp.start_time)
    psd = conditioned.psd(4)
    psd = interpolate(psd, conditioned.delta_f)
    psd = inverse_spectrum_truncation(psd, int(4 * conditioned.sample_rate),
                                  low_frequency_cutoff=15)

    #Filtering the template
    snr = matched_filter(template, conditioned,
                     psd=psd, low_frequency_cutoff=15)
    snr = snr.crop(4 + 4, 4)
    Snr_list.append(max(abs(snr)))
snr = Snr_list

print(snr)
nsnr = (np.array(snr)**2)**0.5
ii = np.where(nsnr == max(nsnr))
pylab.figure(figsize=[10, 4])
pylab.plot(mass1, nsnr)

#Plotting
pylab.ylabel('Signal-to-noise')
pylab.xlabel('mass')
pylab.show()

print("We found the best SNR was %2.2f solar masses " % mass1[ii])

#Getting the strain Vs time

m = 9.20 # Solar masses
conditioned = strain
hp, hc = get_td_waveform(approximant="TaylorT2",
                     mass1=m,
                     mass2=m,
                     delta_t=conditioned.delta_t,
                     f_lower=10.0)

# Resizing the vector to match the data
hp.resize(len(conditioned))

#Getting the template
template = hp .cyclic_time_shift(hp.start_time)

#Plotting the strain
pylab.plot(hp.sample_times, template)
pylab.xlabel('time')
pylab.ylabel('strain')
pylab.title("Strain Vs Time after shifting")
pylab.show()

psd = conditioned.psd(4)
psd = interpolate(psd, conditioned.delta_f)
psd = inverse_spectrum_truncation(psd, int(4 * conditioned.sample_rate),
                                  low_frequency_cutoff=15)

#Filtering the template
snr = matched_filter(template, conditioned,
                  psd=psd, low_frequency_cutoff=15)
#Removing 4 seconds from the beginning and end for the PSD
snr = snr.crop(4 + 4, 4)

#Plotting the SNR to have real values only against time
pylab.figure(figsize=[10, 4])
pylab.plot(snr.sample_times, abs(snr))
pylab.ylabel('Signal-to-noise')
pylab.xlabel('Time (s)')
pylab.title("Signal-To-Noise Vs Time")
pylab.show()

#Setting the parameters
peak = abs(snr).numpy().argmax()
snrp = snr[peak]
time = snr.sample_times[peak]

print("We found a signal at {}s with SNR {}".format(time, abs(snrp)))

print("The data provided has only noise and no signal")

#Problem 2 part 2
#Whitening the data

import pycbc.psd
from pycbc.psd import interpolate
delta_t = strain.delta_t
stilde =  strain.to_frequencyseries()
#segmenting the data
seg_len = int(2 / delta_t)
seg_stride = int(seg_len / 2)
Psds  = pycbc.psd.welch(strain,
                  seg_len=seg_len,
                  seg_stride=seg_stride)

Psds = interpolate(psd, stilde.delta_f)
aligned = template.cyclic_time_shift(DT)
# Whitening the data
white_data = (conditioned.to_frequencyseries() / psd**0.5).to_timeseries()

tapered = aligned.highpass_fir(30, 512, remove_corrupted=False)
white_template = (tapered.to_frequencyseries() / psd**0.5).to_timeseries()

white_data = white_data.highpass_fir(30., 512).lowpass_fir(300, 512)


# Select the time around the merger
white_data = white_data.time_slice(10, 50)
white_template = white_template.time_slice(10, 50)

white_data = white_data.crop(4,4)

import statistics
import matplotlib.pyplot as plt

plt.hist(white_data,bins = 200)

print("Histogram of IQ, mean is " + str(statistics.mean(white_data)))

#Problem 2 part 3
from scipy.optimize._lsq.common import print_header_nonlinear

#Calculating the optimal SNR
from pycbc.filter import sigmasq

from pycbc.waveform import get_fd_waveform


hp, hc = get_fd_waveform(approximant="TaylorF2",
                         mass1=3,
                         mass2=3,
                         delta_f=1.0/(200.0) ,
                         distance = 500,
                         f_lower=20.0, f_final = 2048.0)    #Luminosity distance = 500 Mpc

#Creating the SNR
SNR = (np.sum((4*hp*np.conj(hp)*hp.delta_f/psd).data).real)**0.5
#Error ValueError: different delta_f, otherwise supposed to plost the histogram of SNR
#Plotting the SNR
#plt.hist(SNR)

print(hp.delta_f)